"""Build the Scorecard database structure and populate it with data.

Functions:
    _validate_db_path(db_path): Check validity of database path.
    _validate_data_types_path(data_types_path): Check data types path.
    build_database(): Call functions to build tables and insert data.
    _build_year_tables(): Create year tables.
    _build_table(table_name): Create tables and add appropriate columns.
    sanitize(string): Check strings for characters that could harm database.
    _copy_table(source_table, target_table): Copy an existing table.
"""
import os
import json
import sqlite3

class Dbbuilder:
    """Class with data and methods for building the scorecard database.

    Attributes:
        data_types: List of the data types (columns) in the database.
        db_path: Path to the database being built.
        conn: sqlite3 connection object.
        cur: sqlite3 cursor object.
    """

    def __init__(self, db_path, data_types_path):
        self._validate_db_path(db_path)
        self._validate_data_types_path(data_types_path)

        self.db_path = db_path
        with open(data_types_path, 'r') as data_file:
            self.data_types = json.loads(data_file.readline())

        self.conn = sqlite3.connect(self.db_path)
        self.cur = self.conn.cursor()

    @staticmethod
    def _validate_db_path(db_path):
        """Raise exception for an invalid database path.

        Args:
            db_path: String path of the database to be created.

        Raises:
            TypeError: The data path was not correctly formatted as a string.
        """
        if not isinstance(db_path, str):
            raise TypeError('Database path is not a string')

    @staticmethod
    def _validate_data_types_path(data_types_path):
        """Raise exception for invalid data types path.

        Args:
            data_types_path: Path to the data types file generated by decoder.

        Raises:
            TypeError: The path was not correctly formatted as a string.
            FileNotFoundError: The path is not a valid file.
        """
        if not isinstance(data_types_path, str):
            raise TypeError('Data types path is not a string')
        if not os.path.isfile(data_types_path):
            raise FileNotFoundError(
                'Data type file not found: %s' % data_types_path)

    def build_database(self):
        """Execute functions that create the database tables."""
        self._build_table('College')
        self._build_year_tables()

    def _build_year_tables(self):
        """Execute table-building for the year data."""
        self._build_table('1999')
        for year in range(2000, 2014):
            self._copy_table('1999', str(year))

    def _build_table(self, table_name):
        """Create database tables and add appropriate columns.

        Uses the data_types file generated by the decoder.py script to determine
        the column names and types of data they hold.
        Data types with an index of 1 to 36 belong to the 'College' table
        because they are independent of the year. All other types that differ
        year-to-year belong in the year tables.

        Args:
            table_name: Name of the table ('College' or a year: '2000').
        """
        lower_limit = 1 if table_name == 'College' else 36
        upper_limit = 35 if table_name == 'College' else 1728
        autoincrement = "AUTOINCREMENT" if table_name == 'College' else ''

        self.cur.execute('''
            CREATE TABLE IF NOT EXISTS "%s" (
            college_id INTEGER PRIMARY KEY %s
            )''' % (self.sanitize(table_name), autoincrement))

        for data_type in self.data_types:
            if data_type[2] > upper_limit: break
            if data_type[2] < lower_limit: continue
            try:
                self.cur.execute(
                    '''ALTER TABLE "%s" ADD COLUMN %s %s''' %
                    (self.sanitize(table_name), self.sanitize(data_type[0]),
                     self.sanitize(data_type[1])))
            except sqlite3.OperationalError:
                pass

    def update_database(self, raw_data_path, year):
        """Update the database with data from a file.

        Args:
            raw_data_path: String path to the raw data file.
            year: String source year for the data at raw_data_path.
        """
        if self.data_types is None:
            raise TypeError('Data types not loaded')
        college_categories = self.data_types[0:35]
        year_categories = self.data_types[35:]
        #can open raw_data_path at this point

    @staticmethod
    def sanitize(string):
        """Check input strings for harmful characters.

        Needed for table names, column names, and data types that
        cannot be specified with parameter substitution. Helps to prevent
        SQL injections and unintended errors.

        Args:
            string: String to sanitize.

        Returns:
            string: The string that was passed to the function.

        Raises:
            ValueError: If the string contains an illegal character.
        """
        bad_chars = ['"', "'", ';', '\\', '/']
        for char in bad_chars:
            if char in string:
                raise ValueError('Table input contains ' + char)
        return string


    def _copy_table(self, source_table, target_table):
        """Create a copy of an existing database table with a different name.

        For the year tables that contain the same columns, this is faster than
        looking through all the data types repeatedly.

        Args:
            source_table: String name of the existing table to be copied.
            target_table: String name of the new table.
        """
        self.cur.execute(
            '''SELECT sql FROM sqlite_master WHERE type='table' AND name ="%s"
            ''' % (self.sanitize(source_table)))
        statement = self.cur.fetchone()[0]
        new_statement = statement.replace(
            self.sanitize(source_table), self.sanitize(target_table), 1)
        self.cur.execute(new_statement)
