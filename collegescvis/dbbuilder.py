"""
dbbuilder.py
Copyright (C) <2017>  <S. Cline>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import os
import json
import sqlite3
import decoder
from validator import Validator


class Dbbuilder(object):
    """Class with data and methods for building the scorecard database.

    Attributes:
        data_types: List of the data types (columns) in the database.
        db_path: Path to the database being built.
        conn: sqlite3 connection object.
        cur: sqlite3 cursor object.
    """

    def __init__(self, db_path, data_types_path):
        self._validate_db_path(db_path)
        self._validate_data_types_path(data_types_path)

        self.db_path = db_path

        with open(data_types_path, 'r') as data_file:
            Validator.check_data_types(data_file)
            self.data_types = json.loads(data_file.readline())

        self.conn = sqlite3.connect(self.db_path)
        self.cur = self.conn.cursor()

    @staticmethod
    def _validate_db_path(db_path):
        """Raise exception for an invalid database path.

        Args:
            db_path: String path of the database to be created.

        Raises:
            TypeError: The data path was not correctly formatted as a string.
        """
        if not isinstance(db_path, str):
            raise TypeError('Database path is not a string')

    @staticmethod
    def _validate_data_types_path(data_types_path):
        """Raise exception for invalid data types path.

        Args:
            data_types_path: Path to the data types file generated by decoder.

        Raises:
            TypeError: The path was not correctly formatted as a string.
            FileNotFoundError: The path is not a valid file.
        """
        if not isinstance(data_types_path, str):
            raise TypeError('Data types path is not a string')
        if not os.path.isfile(data_types_path):
            raise FileNotFoundError(
                'Data type file not found: %s' % data_types_path)

    def build_database(self):
        """Execute functions that create the database tables."""
        self._build_table('College')
        self._build_year_tables()

    def _build_year_tables(self):
        """Execute table-building for the year data."""
        self._build_table('1996')
        for year in range(1997, 2015):
            self._copy_table('1996', str(year))

    def _build_table(self, table_name):
        """Create database tables and add appropriate columns.

        Uses the data_types file generated by the decoder.py script to determine
        the column names and types of data they hold.

        Data types with an index of 0 to 35 belong to the 'College' table
        because they are independent of the year. All other types that differ
        year-to-year belong in the year tables.

        Args:
            table_name: Name of the table ('College' or a year: '2000').
        """
        print('Building table: ' + table_name + '...')
        lower_limit = 0 if table_name == 'College' else 36
        upper_limit = 35 if table_name == 'College' else 1742
        autoincrement = "AUTOINCREMENT" if table_name == 'College' else ''

        self.cur.execute('''
            CREATE TABLE IF NOT EXISTS "%s" (
            college_id INTEGER PRIMARY KEY %s
            )''' % (self.sanitize(table_name), autoincrement))

        for data_type in self.data_types:
            if data_type[2] > upper_limit: break
            if data_type[2] < lower_limit: continue
            try:
                self.cur.execute(
                    '''ALTER TABLE "%s" ADD COLUMN %s %s''' %
                    (self.sanitize(table_name), self.sanitize(data_type[0]),
                     self.sanitize(data_type[1])))
            except sqlite3.OperationalError:
                pass
        self.conn.commit()

    def update_database(self, raw_data_path, year):
        """Update the database with data from a file.

        Also checks the table to see if data already exists in the destination
        table. Prompts the user to skip if it is already found.

        Args:
            raw_data_path: String path to the raw data file.
            year: String source year for the data at raw_data_path.

        Raises:
            TypeError: If data types do not exist.
            FileNotFoundError: If the raw data file cannot be found.
        """
        if self.data_types is None:
            raise TypeError('Data types not loaded')

        if not os.path.isfile(raw_data_path):
            raise FileNotFoundError(
                'Raw data file not found: %s' % raw_data_path)

        print('Updating database...')
        #Check if table needs to be updated
        try:
            self.cur.execute('''SELECT Count(*) FROM "%s"''' % (year,))
            count = self.cur.fetchone()[0]
            if int(count) > 1000:
                print('Table: %s appears to already contain data. Would you '
                    'like to continue trying to add the data?' % (year,))
                selection = ''
                while selection != 'y' and selection != 'n':
                    selection = input('(y/n)? ')
                    selection = str.lower(selection)
                    if selection == 'n':
                        return
        except sqlite3.OperationalError:
            pass
        with open(raw_data_path, 'r', encoding='utf-8-sig') as data:
            entries = len(data.readlines()) - 1
            count = 0
            data.seek(0)
            for line in data:
                clean_line = decoder.replace_commas(line)
                if clean_line.startswith('UNITID'):
                    continue
                if (count % 500) == 0:
                    print(count, ' of', entries, 'read from', raw_data_path)
                self._insert_data_(clean_line, year)
                count = count + 1
        self.conn.commit()

    def _insert_data_(self, data, year):
        """Insert data into College and year tables.

        Args:
            data: String of raw data from input file.
            year: String of the data source's year.
        """
        #Clean the raw data. Ensure that data in clean_data matches the
        #indices of data types.
        clean_data = []
        data_list = data.split(',')
        for data_type in self.data_types:
            index = data_type[2]
            data_point = data_list[index]
            if data_point[-1] == '\n': data_point = data_point[:-1]
            if data_point == 'NULL' or data_point == 'PrivacySuppressed':
                clean_data.append(None)
            elif data_type[1] == 'INTEGER':
                clean_data.append(int(data_point))
            elif data_type[1] == 'REAL':
                clean_data.append(float(data_point))
            else:
                clean_data.append(data_point)

        #Find the first index for data going to year table. This finds the
        #index that divides the College table data from the year table data.
        college_upper_limit = 35
        year_start_index = 0
        for i, item in enumerate(self.data_types):
            if item[2] > college_upper_limit:
                year_start_index = i
                break

        #Data insertion into College table
        unitid = clean_data[0]
        selected_row = None
        try:
            self.cur.execute(
                '''SELECT * FROM College WHERE UNITID = %s''' % (unitid,))
            selected_row = self.cur.fetchone()
        except sqlite3.OperationalError:
            pass
        college_id = ''
        if selected_row is None:
            self.cur.execute(
                '''INSERT INTO College VALUES %s''' %
                (self._question_generator(
                    len(clean_data[:year_start_index])+1)),
                ([None] + clean_data[:year_start_index]))
            self.cur.execute(
                '''SELECT college_id FROM College WHERE UNITID = %s''' %
                (self.sanitize(str(unitid)),))
            college_id = self.cur.fetchone()[0]
        else:
            college_id = selected_row[0]

        #Data insertion into year table using the college_id from College table
        self.cur.execute(
            '''SELECT * FROM "%s" WHERE college_id = %s''' % (year, college_id))
        selected_row = self.cur.fetchone()
        if selected_row is None:
            self.cur.execute(
                '''INSERT INTO "%s" VALUES %s''' %
                (year,
                 self._question_generator(
                    len(clean_data[year_start_index:])+1)),
                [college_id] + clean_data[year_start_index:])
        else:
            print('Year row already in table')

    @staticmethod
    def _question_generator(number):
        """Generate a string of question marks for use in insert statements.

        Args:
            number: Integer number of question marks (columns)

        Returns:
            string: String of question marks in the format (?,?,...,?,?)

        Raises:
            ValueError: If the number of question marks is less than 1.
        """
        if number < 1:
            raise ValueError('Number of question marks must be greater than 0.')
        string = '(?)'
        for _ in range(1, number):
            string = string[0] + '?,' + string[1:]
        return string

    @staticmethod
    def sanitize(string):
        """Check input strings for harmful characters.

        Needed for table names, column names, and data types that
        cannot be specified with parameter substitution. Helps to prevent
        SQL injections and unintended errors.

        Args:
            string: String to sanitize.

        Returns:
            string: The string that was passed to the function.

        Raises:
            TypeError: If the argument is not a string.
            ValueError: If the string contains an illegal character.
        """
        if not isinstance(string, str):
            print(string)
            raise TypeError(string + ' is not a valid string.')

        bad_chars = ['"', "'", ';', '\\', '/']
        for char in bad_chars:
            if char in string:
                raise ValueError('Table input contains ' + char)
        return string


    def _copy_table(self, source_table, target_table):
        """Create a copy of an existing database table with a different name.

        For the year tables that contain the same columns, this is faster than
        building each year table from the raw data.

        Args:
            source_table: String name of the existing table to be copied.
            target_table: String name of the new table.
        """
        self.cur.execute(
            '''SELECT sql FROM sqlite_master WHERE type='table' AND name ="%s"
            ''' % (self.sanitize(source_table)))
        statement = self.cur.fetchone()[0]
        new_statement = statement.replace(
            self.sanitize(source_table), self.sanitize(target_table), 1)
        self.cur.execute(new_statement)
