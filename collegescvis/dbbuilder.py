"""Build the Scorecard database structure and populate it with data.

Functions:
    _validate_db_path(db_path): Check validity of database path.
    _validate_data_types_path(data_types_path): Check data types path.
    build_database(): Call functions to build tables and insert data.
    _build_year_tables(): Create year tables.
    _build_table(table_name): Create tables and add appropriate columns.
    update_database(raw_data_path, year): Add raw data to database.
    _insert_data_(data, year): Insert data for one college into the database.
    question_generator(number): Create insert statement question mark string.
    sanitize(string): Check strings for characters that could harm database.
    _copy_table(source_table, target_table): Copy an existing table.
"""
import os
import json
import sqlite3


class Dbbuilder:
    """Class with data and methods for building the scorecard database.

    Attributes:
        data_types: List of the data types (columns) in the database.
        db_path: Path to the database being built.
        conn: sqlite3 connection object.
        cur: sqlite3 cursor object.
    """

    def __init__(self, db_path, data_types_path):
        self._validate_db_path(db_path)
        self._validate_data_types_path(data_types_path)

        self.db_path = db_path
        with open(data_types_path, 'r') as data_file:
            self.data_types = json.loads(data_file.readline())

        self.conn = sqlite3.connect(self.db_path)
        self.cur = self.conn.cursor()

    @staticmethod
    def _validate_db_path(db_path):
        """Raise exception for an invalid database path.

        Args:
            db_path: String path of the database to be created.

        Raises:
            TypeError: The data path was not correctly formatted as a string.
        """
        if not isinstance(db_path, str):
            raise TypeError('Database path is not a string')

    @staticmethod
    def _validate_data_types_path(data_types_path):
        """Raise exception for invalid data types path.

        Args:
            data_types_path: Path to the data types file generated by decoder.

        Raises:
            TypeError: The path was not correctly formatted as a string.
            FileNotFoundError: The path is not a valid file.
        """
        if not isinstance(data_types_path, str):
            raise TypeError('Data types path is not a string')
        if not os.path.isfile(data_types_path):
            raise FileNotFoundError(
                'Data type file not found: %s' % data_types_path)

    def build_database(self):
        """Execute functions that create the database tables."""
        self._build_table('College')
        self._build_year_tables()

    def _build_year_tables(self):
        """Execute table-building for the year data."""
        self._build_table('1996')
        for year in range(1997, 2014):
            self._copy_table('1996', str(year))

    def _build_table(self, table_name):
        """Create database tables and add appropriate columns.

        Uses the data_types file generated by the decoder.py script to determine
        the column names and types of data they hold.
        Data types with an index of 1 to 36 belong to the 'College' table
        because they are independent of the year. All other types that differ
        year-to-year belong in the year tables.

        Args:
            table_name: Name of the table ('College' or a year: '2000').
        """
        lower_limit = 0 if table_name == 'College' else 36
        upper_limit = 35 if table_name == 'College' else 1728
        autoincrement = "AUTOINCREMENT" if table_name == 'College' else ''

        self.cur.execute('''
            CREATE TABLE IF NOT EXISTS "%s" (
            college_id INTEGER PRIMARY KEY %s
            )''' % (self.sanitize(table_name), autoincrement))

        for data_type in self.data_types:
            if data_type[2] > upper_limit: break
            if data_type[2] < lower_limit: continue
            try:
                self.cur.execute(
                    '''ALTER TABLE "%s" ADD COLUMN %s %s''' %
                    (self.sanitize(table_name), self.sanitize(data_type[0]),
                     self.sanitize(data_type[1])))
            except sqlite3.OperationalError:
                pass

    def update_database(self, raw_data_path, year):
        """Update the database with data from a file.

        Args:
            raw_data_path: String path to the raw data file.
            year: String source year for the data at raw_data_path.

        Raises:
            TypeError: If data types do not exist.
            FileNotFoundError: If the raw data file cannot be found.
        """
        if self.data_types is None:
            raise TypeError('Data types not loaded')

        if not os.path.isfile(raw_data_path):
            raise FileNotFoundError(
                'Raw data file not found: %s' % raw_data_path)

        with open(raw_data_path, 'r', encoding='latin-1') as data:
            entries = len(data.readlines()) - 1
            count = 0
            data.seek(0)
            for line in data:
                if line.startswith('UNITID'):
                    continue
                if (count % 250) == 0:
                    print(count, ' of', entries, 'read from', raw_data_path)
                self._insert_data_(line, year)
                count = count + 1
        self.conn.commit()

    def _insert_data_(self, data, year):
        """Insert data into College and year tables.

        Args:
            data: String of raw data from input file.
            year: String of the data source's year.
        """

        #Find indices in raw data to ignore
        skipped_indices = []
        expected_index = 0
        for item in self.data_types:
            while item[2] != expected_index:
                skipped_indices.append(expected_index)
                expected_index = expected_index + 1
            expected_index = expected_index + 1

        #Clean the raw data and leave out skipped data
        clean_data = []
        data_list = data.split(',')
        for data_type in self.data_types:
            index = data_type[2]
            data_point = data_list[index]
            if data_point[-1] == '\n': data_point = data_point[:-1]
            if data_point == 'NULL' or data_point == 'PrivacySuppressed':
                clean_data.append(None)
            elif data_type[1] == 'INTEGER':
                clean_data.append(int(data_point))
            elif data_type[1] == 'REAL':
                clean_data.append(float(data_point))
            else:
                clean_data.append(data_point)

        unitid = clean_data[0]

        #Find the first index for data going to year table
        college_upper_limit = 35
        year_start_index = 0
        for i, item in enumerate(self.data_types):
            if item[2] > college_upper_limit:
                year_start_index = i
                break

        #Data insertion into College table
        #Need to add updating individual items or use most current data
        self.cur.execute(
            '''SELECT * FROM College WHERE UNITID = %s''' % (unitid,))
        selected_row = self.cur.fetchone()
        if selected_row is None:
            self.cur.execute(
                '''INSERT INTO College VALUES %s''' %
                (self.question_generator(len(clean_data[:year_start_index])+1)),
                ([None] + self.sanitize(clean_data[:year_start_index])))

        #Data insertion into Year table
        #Optimize this later
        self.cur.execute(
            '''SELECT college_id FROM College WHERE UNITID = %s''' %
            (self.sanitize(unitid),))
        college_id = self.cur.fetchone()[0]

        self.cur.execute(
            '''SELECT * FROM "%s" WHERE college_id = %s''' % (year, college_id))
        selected_row = self.cur.fetchone()
        if selected_row is None:
            self.cur.execute(
                '''INSERT INTO "%s" VALUES %s''' %
                (year,
                 self.question_generator(len(clean_data[year_start_index:])+1)),
                [college_id] + self.sanitize(clean_data[year_start_index:]))
        else:
            print('Year row already in table')

    @staticmethod
    def question_generator(number):
        """Generate a string of question marks for use in insert statements.

        Args:
            number: Integer number of question marks (columns)

        Returns:
            string: String of question marks in the format (?,?,...,?,?)

        Raises:
            ValueError: If the number of question marks is less than 1.
        """
        if number < 1:
            raise ValueError('Number of question marks must be greater than 0.')
        string = '(?)'
        for question in range(1, number):
            string = string[0] + '?,' + string[1:]
        return string

    @staticmethod
    def sanitize(string):
        """Check input strings for harmful characters.

        Needed for table names, column names, and data types that
        cannot be specified with parameter substitution. Helps to prevent
        SQL injections and unintended errors.

        Args:
            string: String to sanitize.

        Returns:
            string: The string that was passed to the function.

        Raises:
            TypeError: If the argument is not a string.
            ValueError: If the string contains an illegal character.
        """
        if not isinstance(string, str):
            raise TypeError(string + ' is not a valid string.')

        bad_chars = ['"', "'", ';', '\\', '/']
        for char in bad_chars:
            if char in string:
                raise ValueError('Table input contains ' + char)
        return string


    def _copy_table(self, source_table, target_table):
        """Create a copy of an existing database table with a different name.

        For the year tables that contain the same columns, this is faster than
        looking through all the data types repeatedly.

        Args:
            source_table: String name of the existing table to be copied.
            target_table: String name of the new table.
        """
        self.cur.execute(
            '''SELECT sql FROM sqlite_master WHERE type='table' AND name ="%s"
            ''' % (self.sanitize(source_table)))
        statement = self.cur.fetchone()[0]
        new_statement = statement.replace(
            self.sanitize(source_table), self.sanitize(target_table), 1)
        self.cur.execute(new_statement)
