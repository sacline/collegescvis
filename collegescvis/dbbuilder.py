"""Build the Scorecard database structure and populate it with data.

Functions:
    _validate_db_path(db_path): Check validity of database path.
    _validate_data_types_path(data_types_path): Check data types path.
    initialize_database(db_path, data_types_path): Set necessary db vars.
    build_database(): Call functions to build tables and insert data.
    _build_year_tables(): Create year tables.
    _build_table(table_name): Create tables and add appropriate columns.
    sanitize(string): Check strings for characters that could harm database.
    _copy_table(source_table, target_table): Copy an existing table.
"""
import os
import json
import sqlite3

DATA_TYPES = None
DB_PATH = None
CONN = None
CUR = None


def _validate_db_path(db_path):
    """Raise exception for an invalid database path.

    Args:
        db_path: String path of the database to be created.

    Raises:
        TypeError: The data path was not correctly formatted as a string.
    """
    if not isinstance(db_path, str):
        raise TypeError('Database path is not a string')


def _validate_data_types_path(data_types_path):
    """Raise exception for invalid data types path.

    Args:
        data_types_path: Path to the data types file generated by decoder.

    Raises:
        TypeError: The path was not correctly formatted as a string.
        FileNotFoundError: The path is not a valid file.
    """
    if not isinstance(data_types_path, str):
        raise TypeError('Data types path is not a string')
    if not os.path.isfile(data_types_path):
        raise FileNotFoundError(
            'Data type file not found: %s' % data_types_path)


def initialize_database(db_path, data_types_path):
    """Set variables needed to build the database.

    Args:
        db_path: Path to the database file to be created.
        data_types_path: Path to existing data types file generated by decoder.
    """
    _validate_db_path(db_path)
    _validate_data_types_path(data_types_path)
    global DB_PATH
    DB_PATH = db_path

    global DATA_TYPES
    with open(data_types_path, 'r') as data_file:
        DATA_TYPES = json.loads(data_file.readline())

    global CONN
    CONN = sqlite3.connect(DB_PATH)

    global CUR
    CUR = CONN.cursor()

def build_database():
    """Execute functions that create the database tables."""
    _build_table('College')
    _build_year_tables()

def _build_year_tables():
    """Execute table-building for the year data."""
    _build_table('1999')
    for year in range(2000, 2014):
        _copy_table('1999', str(year))


def _build_table(table_name):
    """Create database tables and add appropriate columns.

    Uses the data_types file generated by the decoder.py script to determine
    the column names and types of data they hold.
    Data types with an index of 1 to 36 belong to the 'College' table because
    they are independent of the year. All other types that differ year-to-year
    belong in the year tables.

    Args:
        table_name: Name of the table ('College' or a year: '2000').
    """
    lower_limit = 1 if table_name == 'College' else 37
    upper_limit = 36 if table_name == 'College' else 1728
    autoincrement = "AUTOINCREMENT" if table_name == 'College' else ''

    CUR.execute('''
        CREATE TABLE IF NOT EXISTS "%s" (
        college_id INTEGER PRIMARY KEY %s
        )''' % (sanitize(table_name), autoincrement))

    for data_type in DATA_TYPES:
        if data_type[2] > upper_limit: break
        if data_type[2] < lower_limit: continue
        try:
            CUR.execute(
                '''ALTER TABLE "%s" ADD COLUMN %s %s''' %
                (sanitize(table_name), sanitize(data_type[0]),
                 sanitize(data_type[1])))
        except sqlite3.OperationalError:
            pass


def sanitize(string):
    """Check input strings for harmful characters.

    Needed for table names, column names, and data types that
    cannot be specified with parameter substitution. Helps to prevent
    SQL injections and unintended errors.

    Args:
        string: String to sanitize.

    Returns:
        string: The string that was passed to the function.

    Raises:
        ValueError: If the string contains an illegal character.
    """
    bad_chars = ['"', "'", ';', '\\', '/']
    for char in bad_chars:
        if char in string:
            raise ValueError('Table input contains ' + char)
    return string


def _copy_table(source_table, target_table):
    """Create a copy of an existing database table with a different name.

    For the year tables that contain the same columns, this is faster than
    looking through all the data types repeatedly.

    Args:
        source_table: String name of the existing table to be copied.
        target_table: String name of the new table.
    """
    CUR.execute(
        '''SELECT sql FROM sqlite_master WHERE type='table' AND name ="%s"
        ''' % (sanitize(source_table)))
    statement = CUR.fetchone()[0]
    new_statement = statement.replace(
        sanitize(source_table), sanitize(target_table), 1)
    CUR.execute(new_statement)
